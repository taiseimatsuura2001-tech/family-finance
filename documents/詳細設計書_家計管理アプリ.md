# 家計管理アプリケーション 詳細設計書

## 1. 技術スタック詳細

### 1.1 フロントエンド

```json
{
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.3.0",
    "@tanstack/react-query": "^5.0.0",
    "next-auth": "^4.24.0",
    "recharts": "^2.10.0",
    "@radix-ui/react-dialog": "^1.0.0",
    "@radix-ui/react-select": "^2.0.0",
    "react-hook-form": "^7.48.0",
    "zod": "^3.22.0",
    "@hookform/resolvers": "^3.3.0",
    "date-fns": "^3.0.0",
    "axios": "^1.6.0",
    "tailwindcss": "^3.4.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "lucide-react": "^0.300.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/node": "^20.10.0",
    "eslint": "^8.56.0",
    "prettier": "^3.1.0",
    "jest": "^29.7.0",
    "@testing-library/react": "^14.1.0",
    "@playwright/test": "^1.40.0"
  }
}
```

### 1.2 バックエンド（Prisma Schema）

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String       @id @default(uuid())
  email         String       @unique
  name          String
  role          Role         @default(USER)
  googleId      String?      @unique
  microsoftId   String?      @unique
  isActive      Boolean      @default(true)
  lastLogin     DateTime?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  
  transactions  Transaction[]
  categories    Category[]
  paymentMethods PaymentMethod[]
  budgets       Budget[]
  goals         Goal[]
  auditLogs     AuditLog[]
  
  @@index([email])
  @@index([googleId])
  @@index([microsoftId])
}

enum Role {
  ADMIN
  USER
}

model Category {
  id          String      @id @default(uuid())
  userId      String
  name        String
  type        TransactionType
  color       String      @default("#000000")
  sortOrder   Int         @default(0)
  isDefault   Boolean     @default(false)
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  user        User        @relation(fields: [userId], references: [id])
  subcategories SubCategory[]
  transactions Transaction[]
  budgets     Budget[]
  
  @@index([userId])
  @@index([type])
}

model SubCategory {
  id          String      @id @default(uuid())
  categoryId  String
  name        String
  sortOrder   Int         @default(0)
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  
  category    Category    @relation(fields: [categoryId], references: [id])
  transactions Transaction[]
  
  @@index([categoryId])
}

model Transaction {
  id               String      @id @default(uuid())
  userId           String
  categoryId       String
  subcategoryId    String?
  paymentMethodId  String?
  type             TransactionType
  amount           Decimal     @db.Decimal(12, 2)
  transactionDate  DateTime    @db.Date
  description      String?
  vendor           String?
  isRecurring      Boolean     @default(false)
  recurringPattern String?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  deletedAt        DateTime?
  
  user          User           @relation(fields: [userId], references: [id])
  category      Category       @relation(fields: [categoryId], references: [id])
  subcategory   SubCategory?   @relation(fields: [subcategoryId], references: [id])
  paymentMethod PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  receipts      Receipt[]
  
  @@index([userId])
  @@index([categoryId])
  @@index([transactionDate])
  @@index([type])
  @@index([userId, transactionDate])
}

enum TransactionType {
  INCOME
  EXPENSE
}

model PaymentMethod {
  id          String      @id @default(uuid())
  userId      String
  name        String
  type        PaymentType
  details     String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  
  user        User        @relation(fields: [userId], references: [id])
  transactions Transaction[]
  
  @@index([userId])
}

enum PaymentType {
  CASH
  CREDIT
  DEBIT
  EMONEY
  BANK
}

model Budget {
  id          String      @id @default(uuid())
  userId      String
  categoryId  String
  amount      Decimal     @db.Decimal(12, 2)
  periodType  PeriodType
  startDate   DateTime    @db.Date
  endDate     DateTime    @db.Date
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  user        User        @relation(fields: [userId], references: [id])
  category    Category    @relation(fields: [categoryId], references: [id])
  
  @@index([userId])
  @@index([categoryId])
}

enum PeriodType {
  MONTHLY
  YEARLY
}

model Receipt {
  id            String      @id @default(uuid())
  transactionId String
  fileUrl       String
  fileName      String
  fileSize      Int
  uploadedAt    DateTime    @default(now())
  
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  
  @@index([transactionId])
}

model Goal {
  id            String      @id @default(uuid())
  userId        String
  name          String
  targetAmount  Decimal     @db.Decimal(12, 2)
  currentAmount Decimal     @db.Decimal(12, 2) @default(0)
  targetDate    DateTime    @db.Date
  status        GoalStatus  @default(ACTIVE)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  user          User        @relation(fields: [userId], references: [id])
  
  @@index([userId])
}

enum GoalStatus {
  ACTIVE
  ACHIEVED
  CANCELLED
}

model AuditLog {
  id          String      @id @default(uuid())
  userId      String
  action      String
  entityType  String
  entityId    String
  beforeData  Json?
  afterData   Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime    @default(now())
  
  user        User        @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
}
```

## 2. 認証システム詳細設計

### 2.1 NextAuth.js設定

```typescript
// src/lib/auth/auth.config.ts
import { NextAuthOptions } from "next-auth"
import GoogleProvider from "next-auth/providers/google"
import AzureADProvider from "next-auth/providers/azure-ad"
import { PrismaAdapter } from "@next-auth/prisma-adapter"
import { prisma } from "@/lib/db/prisma"

const ALLOWED_EMAILS = [
  process.env.USER1_EMAIL!,
  process.env.USER2_EMAIL!
]

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code"
        }
      }
    }),
    AzureADProvider({
      clientId: process.env.AZURE_AD_CLIENT_ID!,
      clientSecret: process.env.AZURE_AD_CLIENT_SECRET!,
      tenantId: process.env.AZURE_AD_TENANT_ID!,
    })
  ],
  callbacks: {
    async signIn({ user, account, profile }) {
      // ホワイトリストチェック
      if (!ALLOWED_EMAILS.includes(user.email!)) {
        return false
      }
      
      // ユーザー情報の更新
      await prisma.user.update({
        where: { email: user.email! },
        data: { 
          lastLogin: new Date(),
          [`${account?.provider}Id`]: account?.providerAccountId
        }
      })
      
      return true
    },
    async session({ session, user }) {
      if (session?.user) {
        session.user.id = user.id
        session.user.role = user.role
      }
      return session
    },
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.role = user.role
      }
      return token
    }
  },
  pages: {
    signIn: '/login',
    error: '/auth/error',
  },
  session: {
    strategy: "jwt",
    maxAge: 30 * 60, // 30分
  },
  jwt: {
    secret: process.env.NEXTAUTH_SECRET,
  }
}
```

### 2.2 認証ミドルウェア

```typescript
// src/middleware.ts
import { withAuth } from "next-auth/middleware"
import { NextResponse } from "next/server"

export default withAuth(
  function middleware(req) {
    const token = req.nextauth.token
    const isAuth = !!token
    const isAuthPage = req.nextUrl.pathname.startsWith("/login")

    if (isAuthPage) {
      if (isAuth) {
        return NextResponse.redirect(new URL("/dashboard", req.url))
      }
      return null
    }

    if (!isAuth) {
      let from = req.nextUrl.pathname
      if (req.nextUrl.search) {
        from += req.nextUrl.search
      }
      return NextResponse.redirect(
        new URL(`/login?from=${encodeURIComponent(from)}`, req.url)
      )
    }

    // Rate limiting
    const ip = req.ip ?? "127.0.0.1"
    const rateLimit = getRateLimiter(ip)
    if (!rateLimit.check()) {
      return new NextResponse("Too Many Requests", { status: 429 })
    }
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token
    },
  }
)

export const config = {
  matcher: ["/dashboard/:path*", "/api/:path*", "/login"]
}
```

## 3. APIエンドポイント詳細設計

### 3.1 Transaction API実装

```typescript
// src/app/api/transactions/route.ts
import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth/auth.config"
import { prisma } from "@/lib/db/prisma"
import { z } from "zod"
import { auditLog } from "@/lib/utils/audit"

// バリデーションスキーマ
const createTransactionSchema = z.object({
  type: z.enum(["INCOME", "EXPENSE"]),
  amount: z.number().positive(),
  categoryId: z.string().uuid(),
  subcategoryId: z.string().uuid().optional(),
  paymentMethodId: z.string().uuid().optional(),
  transactionDate: z.string().datetime(),
  description: z.string().optional(),
  vendor: z.string().optional(),
  isRecurring: z.boolean().optional(),
  recurringPattern: z.string().optional()
})

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const searchParams = req.nextUrl.searchParams
    const startDate = searchParams.get("startDate")
    const endDate = searchParams.get("endDate")
    const type = searchParams.get("type")
    const categoryId = searchParams.get("categoryId")
    const page = parseInt(searchParams.get("page") || "1")
    const limit = parseInt(searchParams.get("limit") || "20")

    const where = {
      userId: session.user.id,
      deletedAt: null,
      ...(startDate && endDate && {
        transactionDate: {
          gte: new Date(startDate),
          lte: new Date(endDate)
        }
      }),
      ...(type && { type }),
      ...(categoryId && { categoryId })
    }

    const [transactions, total] = await prisma.$transaction([
      prisma.transaction.findMany({
        where,
        include: {
          category: true,
          subcategory: true,
          paymentMethod: true,
          receipts: true
        },
        orderBy: { transactionDate: "desc" },
        skip: (page - 1) * limit,
        take: limit
      }),
      prisma.transaction.count({ where })
    ])

    return NextResponse.json({
      success: true,
      data: transactions,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error("Error fetching transactions:", error)
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    )
  }
}

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body = await req.json()
    const validatedData = createTransactionSchema.parse(body)

    const transaction = await prisma.transaction.create({
      data: {
        ...validatedData,
        userId: session.user.id,
        transactionDate: new Date(validatedData.transactionDate)
      },
      include: {
        category: true,
        subcategory: true,
        paymentMethod: true
      }
    })

    // 監査ログ記録
    await auditLog({
      userId: session.user.id,
      action: "CREATE",
      entityType: "Transaction",
      entityId: transaction.id,
      afterData: transaction,
      ipAddress: req.ip,
      userAgent: req.headers.get("user-agent")
    })

    return NextResponse.json({
      success: true,
      data: transaction
    })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation Error", details: error.errors },
        { status: 400 }
      )
    }
    console.error("Error creating transaction:", error)
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    )
  }
}
```

### 3.2 Report API実装

```typescript
// src/app/api/reports/summary/route.ts
import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth/auth.config"
import { prisma } from "@/lib/db/prisma"
import { startOfMonth, endOfMonth, startOfYear, endOfYear } from "date-fns"

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const searchParams = req.nextUrl.searchParams
    const period = searchParams.get("period") || "monthly"
    const dateStr = searchParams.get("date") || new Date().toISOString()
    const date = new Date(dateStr)

    let startDate: Date
    let endDate: Date

    switch (period) {
      case "monthly":
        startDate = startOfMonth(date)
        endDate = endOfMonth(date)
        break
      case "yearly":
        startDate = startOfYear(date)
        endDate = endOfYear(date)
        break
      default:
        startDate = startOfMonth(date)
        endDate = endOfMonth(date)
    }

    // 収支集計
    const [incomeSum, expenseSum, categoryBreakdown] = await Promise.all([
      // 収入合計
      prisma.transaction.aggregate({
        where: {
          userId: session.user.id,
          type: "INCOME",
          transactionDate: { gte: startDate, lte: endDate },
          deletedAt: null
        },
        _sum: { amount: true }
      }),
      // 支出合計
      prisma.transaction.aggregate({
        where: {
          userId: session.user.id,
          type: "EXPENSE",
          transactionDate: { gte: startDate, lte: endDate },
          deletedAt: null
        },
        _sum: { amount: true }
      }),
      // カテゴリー別集計
      prisma.transaction.groupBy({
        by: ["categoryId", "type"],
        where: {
          userId: session.user.id,
          transactionDate: { gte: startDate, lte: endDate },
          deletedAt: null
        },
        _sum: { amount: true }
      })
    ])

    // カテゴリー情報を取得
    const categoryIds = categoryBreakdown.map(item => item.categoryId)
    const categories = await prisma.category.findMany({
      where: { id: { in: categoryIds } }
    })

    const categoryMap = new Map(categories.map(cat => [cat.id, cat]))

    const totalIncome = incomeSum._sum.amount?.toNumber() || 0
    const totalExpense = expenseSum._sum.amount?.toNumber() || 0

    const breakdown = categoryBreakdown.map(item => {
      const category = categoryMap.get(item.categoryId)
      const amount = item._sum.amount?.toNumber() || 0
      const total = item.type === "INCOME" ? totalIncome : totalExpense
      
      return {
        categoryId: item.categoryId,
        categoryName: category?.name || "Unknown",
        type: item.type,
        amount,
        percentage: total > 0 ? (amount / total) * 100 : 0
      }
    })

    return NextResponse.json({
      success: true,
      data: {
        period: {
          start: startDate.toISOString(),
          end: endDate.toISOString()
        },
        totalIncome,
        totalExpense,
        balance: totalIncome - totalExpense,
        categoryBreakdown: breakdown
      }
    })
  } catch (error) {
    console.error("Error generating report:", error)
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    )
  }
}
```

## 4. コンポーネント詳細設計

### 4.1 Transaction Form Component

```typescript
// src/components/forms/TransactionForm.tsx
"use client"

import { useState } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { useMutation, useQuery } from "@tanstack/react-query"
import { format } from "date-fns"
import { Calendar } from "@/components/ui/calendar"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select } from "@/components/ui/select"
import { Textarea } from "@/components/ui/textarea"
import { Switch } from "@/components/ui/switch"
import { toast } from "@/components/ui/toast"
import { api } from "@/lib/api"

const transactionSchema = z.object({
  type: z.enum(["INCOME", "EXPENSE"]),
  amount: z.number().positive("金額は正の数である必要があります"),
  categoryId: z.string().min(1, "カテゴリーを選択してください"),
  subcategoryId: z.string().optional(),
  paymentMethodId: z.string().optional(),
  transactionDate: z.date(),
  description: z.string().optional(),
  vendor: z.string().optional(),
  isRecurring: z.boolean().default(false),
  recurringPattern: z.string().optional()
})

type TransactionFormData = z.infer<typeof transactionSchema>

interface TransactionFormProps {
  defaultValues?: Partial<TransactionFormData>
  onSuccess?: () => void
}

export function TransactionForm({ 
  defaultValues, 
  onSuccess 
}: TransactionFormProps) {
  const [selectedDate, setSelectedDate] = useState<Date>(
    defaultValues?.transactionDate || new Date()
  )

  const { 
    register, 
    handleSubmit, 
    watch, 
    setValue,
    formState: { errors } 
  } = useForm<TransactionFormData>({
    resolver: zodResolver(transactionSchema),
    defaultValues: {
      type: "EXPENSE",
      transactionDate: new Date(),
      isRecurring: false,
      ...defaultValues
    }
  })

  const type = watch("type")
  const categoryId = watch("categoryId")
  const isRecurring = watch("isRecurring")

  // カテゴリー取得
  const { data: categories } = useQuery({
    queryKey: ["categories", type],
    queryFn: () => api.getCategories({ type })
  })

  // サブカテゴリー取得
  const { data: subcategories } = useQuery({
    queryKey: ["subcategories", categoryId],
    queryFn: () => api.getSubcategories(categoryId),
    enabled: !!categoryId
  })

  // 支払方法取得
  const { data: paymentMethods } = useQuery({
    queryKey: ["paymentMethods"],
    queryFn: () => api.getPaymentMethods()
  })

  // トランザクション作成
  const createMutation = useMutation({
    mutationFn: (data: TransactionFormData) => api.createTransaction(data),
    onSuccess: () => {
      toast.success(
        type === "INCOME" ? "収入を登録しました" : "支出を登録しました"
      )
      onSuccess?.()
    },
    onError: (error) => {
      toast.error("登録に失敗しました")
      console.error(error)
    }
  })

  const onSubmit = (data: TransactionFormData) => {
    createMutation.mutate(data)
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* 種別選択 */}
      <div>
        <label className="block text-sm font-medium mb-2">
          種別
        </label>
        <div className="flex gap-4">
          <label className="flex items-center">
            <input
              type="radio"
              value="INCOME"
              {...register("type")}
              className="mr-2"
            />
            収入
          </label>
          <label className="flex items-center">
            <input
              type="radio"
              value="EXPENSE"
              {...register("type")}
              className="mr-2"
            />
            支出
          </label>
        </div>
        {errors.type && (
          <p className="text-red-500 text-sm mt-1">{errors.type.message}</p>
        )}
      </div>

      {/* 金額入力 */}
      <div>
        <label htmlFor="amount" className="block text-sm font-medium mb-2">
          金額
        </label>
        <Input
          id="amount"
          type="number"
          placeholder="0"
          {...register("amount", { valueAsNumber: true })}
          className="w-full"
        />
        {errors.amount && (
          <p className="text-red-500 text-sm mt-1">{errors.amount.message}</p>
        )}
      </div>

      {/* カテゴリー選択 */}
      <div>
        <label htmlFor="categoryId" className="block text-sm font-medium mb-2">
          カテゴリー
        </label>
        <Select
          id="categoryId"
          {...register("categoryId")}
          className="w-full"
        >
          <option value="">選択してください</option>
          {categories?.map((category) => (
            <option key={category.id} value={category.id}>
              {category.name}
            </option>
          ))}
        </Select>
        {errors.categoryId && (
          <p className="text-red-500 text-sm mt-1">
            {errors.categoryId.message}
          </p>
        )}
      </div>

      {/* サブカテゴリー選択 */}
      {subcategories && subcategories.length > 0 && (
        <div>
          <label 
            htmlFor="subcategoryId" 
            className="block text-sm font-medium mb-2"
          >
            サブカテゴリー
          </label>
          <Select
            id="subcategoryId"
            {...register("subcategoryId")}
            className="w-full"
          >
            <option value="">選択してください</option>
            {subcategories.map((subcategory) => (
              <option key={subcategory.id} value={subcategory.id}>
                {subcategory.name}
              </option>
            ))}
          </Select>
        </div>
      )}

      {/* 日付選択 */}
      <div>
        <label className="block text-sm font-medium mb-2">
          日付
        </label>
        <Calendar
          selected={selectedDate}
          onSelect={(date) => {
            if (date) {
              setSelectedDate(date)
              setValue("transactionDate", date)
            }
          }}
        />
      </div>

      {/* 支払方法（支出の場合のみ） */}
      {type === "EXPENSE" && (
        <div>
          <label 
            htmlFor="paymentMethodId" 
            className="block text-sm font-medium mb-2"
          >
            支払方法
          </label>
          <Select
            id="paymentMethodId"
            {...register("paymentMethodId")}
            className="w-full"
          >
            <option value="">選択してください</option>
            {paymentMethods?.map((method) => (
              <option key={method.id} value={method.id}>
                {method.name}
              </option>
            ))}
          </Select>
        </div>
      )}

      {/* 取引先 */}
      <div>
        <label htmlFor="vendor" className="block text-sm font-medium mb-2">
          {type === "INCOME" ? "支払元" : "支払先"}
        </label>
        <Input
          id="vendor"
          type="text"
          {...register("vendor")}
          className="w-full"
        />
      </div>

      {/* 説明 */}
      <div>
        <label htmlFor="description" className="block text-sm font-medium mb-2">
          メモ
        </label>
        <Textarea
          id="description"
          {...register("description")}
          rows={3}
          className="w-full"
        />
      </div>

      {/* 定期取引設定 */}
      <div>
        <div className="flex items-center space-x-2">
          <Switch
            id="isRecurring"
            checked={isRecurring}
            onCheckedChange={(checked) => setValue("isRecurring", checked)}
          />
          <label htmlFor="isRecurring" className="text-sm font-medium">
            定期的な取引として登録
          </label>
        </div>
        
        {isRecurring && (
          <div className="mt-4">
            <label 
              htmlFor="recurringPattern" 
              className="block text-sm font-medium mb-2"
            >
              繰り返しパターン
            </label>
            <Select
              id="recurringPattern"
              {...register("recurringPattern")}
              className="w-full"
            >
              <option value="daily">毎日</option>
              <option value="weekly">毎週</option>
              <option value="monthly">毎月</option>
              <option value="yearly">毎年</option>
            </Select>
          </div>
        )}
      </div>

      {/* 送信ボタン */}
      <div className="flex justify-end space-x-4">
        <Button
          type="button"
          variant="outline"
          onClick={() => onSuccess?.()}
        >
          キャンセル
        </Button>
        <Button
          type="submit"
          disabled={createMutation.isPending}
        >
          {createMutation.isPending ? "登録中..." : "登録"}
        </Button>
      </div>
    </form>
  )
}
```

### 4.2 Dashboard Chart Component

```typescript
// src/components/charts/DashboardChart.tsx
"use client"

import { useMemo } from "react"
import {
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  Tooltip,
  Legend,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  LineChart,
  Line
} from "recharts"
import { format } from "date-fns"
import { ja } from "date-fns/locale"

interface ChartData {
  name: string
  value: number
  percentage?: number
}

interface DashboardChartProps {
  type: "pie" | "bar" | "line"
  data: ChartData[]
  title: string
  colors?: string[]
}

const DEFAULT_COLORS = [
  "#3B82F6", // blue-500
  "#10B981", // emerald-500
  "#F59E0B", // amber-500
  "#EF4444", // red-500
  "#8B5CF6", // violet-500
  "#EC4899", // pink-500
  "#6366F1", // indigo-500
  "#14B8A6", // teal-500
]

export function DashboardChart({
  type,
  data,
  title,
  colors = DEFAULT_COLORS
}: DashboardChartProps) {
  const chartData = useMemo(() => {
    return data.map((item, index) => ({
      ...item,
      color: colors[index % colors.length]
    }))
  }, [data, colors])

  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white p-3 rounded-lg shadow-lg border">
          <p className="font-semibold">{label || payload[0].name}</p>
          <p className="text-sm">
            金額: ¥{payload[0].value.toLocaleString()}
          </p>
          {payload[0].payload.percentage && (
            <p className="text-sm">
              割合: {payload[0].payload.percentage.toFixed(1)}%
            </p>
          )}
        </div>
      )
    }
    return null
  }

  const renderChart = () => {
    switch (type) {
      case "pie":
        return (
          <PieChart>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              labelLine={false}
              label={({ percentage }) => `${percentage.toFixed(0)}%`}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={entry.color} />
              ))}
            </Pie>
            <Tooltip content={<CustomTooltip />} />
            <Legend />
          </PieChart>
        )

      case "bar":
        return (
          <BarChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip content={<CustomTooltip />} />
            <Bar dataKey="value" fill="#3B82F6" />
          </BarChart>
        )

      case "line":
        return (
          <LineChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip content={<CustomTooltip />} />
            <Line
              type="monotone"
              dataKey="value"
              stroke="#3B82F6"
              strokeWidth={2}
            />
          </LineChart>
        )

      default:
        return null
    }
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">{title}</h3>
      <ResponsiveContainer width="100%" height={300}>
        {renderChart()}
      </ResponsiveContainer>
    </div>
  )
}
```

## 5. ユーティリティ関数

### 5.1 API Client

```typescript
// src/lib/api/client.ts
import axios, { AxiosInstance } from "axios"
import { getSession } from "next-auth/react"

class ApiClient {
  private client: AxiosInstance

  constructor() {
    this.client = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_URL || "/api",
      headers: {
        "Content-Type": "application/json"
      }
    })

    // リクエストインターセプター
    this.client.interceptors.request.use(
      async (config) => {
        const session = await getSession()
        if (session?.user) {
          config.headers.Authorization = `Bearer ${session.user.token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // レスポンスインターセプター
    this.client.interceptors.response.use(
      (response) => response.data,
      (error) => {
        if (error.response?.status === 401) {
          window.location.href = "/login"
        }
        return Promise.reject(error)
      }
    )
  }

  // Transactions
  async getTransactions(params?: any) {
    return this.client.get("/transactions", { params })
  }

  async createTransaction(data: any) {
    return this.client.post("/transactions", data)
  }

  async updateTransaction(id: string, data: any) {
    return this.client.put(`/transactions/${id}`, data)
  }

  async deleteTransaction(id: string) {
    return this.client.delete(`/transactions/${id}`)
  }

  // Categories
  async getCategories(params?: any) {
    return this.client.get("/categories", { params })
  }

  async createCategory(data: any) {
    return this.client.post("/categories", data)
  }

  // Reports
  async getSummaryReport(params: any) {
    return this.client.get("/reports/summary", { params })
  }

  // その他のメソッド...
}

export const api = new ApiClient()
```

### 5.2 監査ログ

```typescript
// src/lib/utils/audit.ts
import { prisma } from "@/lib/db/prisma"

interface AuditLogParams {
  userId: string
  action: string
  entityType: string
  entityId: string
  beforeData?: any
  afterData?: any
  ipAddress?: string | null
  userAgent?: string | null
}

export async function auditLog(params: AuditLogParams) {
  try {
    await prisma.auditLog.create({
      data: {
        userId: params.userId,
        action: params.action,
        entityType: params.entityType,
        entityId: params.entityId,
        beforeData: params.beforeData || undefined,
        afterData: params.afterData || undefined,
        ipAddress: params.ipAddress || undefined,
        userAgent: params.userAgent || undefined
      }
    })
  } catch (error) {
    console.error("Failed to create audit log:", error)
  }
}
```

## 6. セキュリティ実装

### 6.1 CSRFトークン

```typescript
// src/lib/security/csrf.ts
import { createHash } from "crypto"
import { cookies } from "next/headers"

export function generateCSRFToken(): string {
  const token = createHash("sha256")
    .update(Date.now().toString() + Math.random().toString())
    .digest("hex")
  
  cookies().set("csrf-token", token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 60 * 60 // 1時間
  })
  
  return token
}

export function validateCSRFToken(token: string): boolean {
  const storedToken = cookies().get("csrf-token")?.value
  return storedToken === token
}
```

### 6.2 Rate Limiting

```typescript
// src/lib/security/rateLimiter.ts
import { LRUCache } from "lru-cache"

interface RateLimiterOptions {
  uniqueTokenPerInterval?: number
  interval?: number
}

export function rateLimit(options?: RateLimiterOptions) {
  const tokenCache = new LRUCache({
    max: options?.uniqueTokenPerInterval || 500,
    ttl: options?.interval || 60000 // 1分
  })

  return {
    check: (token: string, limit: number) => {
      const tokenCount = (tokenCache.get(token) as number[]) || [0]
      
      if (tokenCount[0] === 0) {
        tokenCache.set(token, [1])
        return true
      }

      if (tokenCount[0] >= limit) {
        return false
      }

      tokenCount[0] += 1
      tokenCache.set(token, tokenCount)
      return true
    }
  }
}
```

## 7. バッチ処理実装

### 7.1 定期取引の自動登録

```typescript
// src/app/api/cron/recurring-transactions/route.ts
import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/db/prisma"
import { addDays, addWeeks, addMonths, addYears } from "date-fns"

export async function GET(req: NextRequest) {
  // Vercel Cronからのリクエストを検証
  const authHeader = req.headers.get("authorization")
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  try {
    // 定期取引を取得
    const recurringTransactions = await prisma.transaction.findMany({
      where: {
        isRecurring: true,
        deletedAt: null
      }
    })

    const newTransactions = []

    for (const transaction of recurringTransactions) {
      const lastTransaction = await prisma.transaction.findFirst({
        where: {
          userId: transaction.userId,
          categoryId: transaction.categoryId,
          isRecurring: false,
          // 元の定期取引と同じ金額
          amount: transaction.amount
        },
        orderBy: {
          transactionDate: "desc"
        }
      })

      let nextDate = new Date()
      
      if (lastTransaction) {
        switch (transaction.recurringPattern) {
          case "daily":
            nextDate = addDays(lastTransaction.transactionDate, 1)
            break
          case "weekly":
            nextDate = addWeeks(lastTransaction.transactionDate, 1)
            break
          case "monthly":
            nextDate = addMonths(lastTransaction.transactionDate, 1)
            break
          case "yearly":
            nextDate = addYears(lastTransaction.transactionDate, 1)
            break
        }
      }

      // 今日の日付と比較
      if (nextDate <= new Date()) {
        const newTransaction = await prisma.transaction.create({
          data: {
            userId: transaction.userId,
            categoryId: transaction.categoryId,
            subcategoryId: transaction.subcategoryId,
            paymentMethodId: transaction.paymentMethodId,
            type: transaction.type,
            amount: transaction.amount,
            transactionDate: nextDate,
            description: `[定期] ${transaction.description}`,
            vendor: transaction.vendor,
            isRecurring: false
          }
        })
        
        newTransactions.push(newTransaction)
      }
    }

    return NextResponse.json({
      success: true,
      created: newTransactions.length,
      transactions: newTransactions
    })
  } catch (error) {
    console.error("Error processing recurring transactions:", error)
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    )
  }
}
```

## 8. テスト実装

### 8.1 単体テスト

```typescript
// tests/unit/api/transactions.test.ts
import { describe, it, expect, jest, beforeEach } from "@jest/globals"
import { POST } from "@/app/api/transactions/route"
import { prisma } from "@/lib/db/prisma"
import { getServerSession } from "next-auth/next"

jest.mock("next-auth/next")
jest.mock("@/lib/db/prisma", () => ({
  prisma: {
    transaction: {
      create: jest.fn(),
      findMany: jest.fn(),
      count: jest.fn()
    }
  }
}))

describe("Transaction API", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe("POST /api/transactions", () => {
    it("should create a new transaction", async () => {
      const mockSession = {
        user: { id: "user-123", email: "test@example.com" }
      }
      
      ;(getServerSession as jest.Mock).mockResolvedValue(mockSession)
      
      const mockTransaction = {
        id: "trans-123",
        userId: "user-123",
        type: "EXPENSE",
        amount: 1000,
        categoryId: "cat-123"
      }
      
      ;(prisma.transaction.create as jest.Mock).mockResolvedValue(
        mockTransaction
      )

      const request = new Request("http://localhost:3000/api/transactions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          type: "EXPENSE",
          amount: 1000,
          categoryId: "cat-123",
          transactionDate: new Date().toISOString()
        })
      })

      const response = await POST(request as any)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.success).toBe(true)
      expect(data.data.id).toBe("trans-123")
    })

    it("should return 401 for unauthorized request", async () => {
      ;(getServerSession as jest.Mock).mockResolvedValue(null)

      const request = new Request("http://localhost:3000/api/transactions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({})
      })

      const response = await POST(request as any)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe("Unauthorized")
    })
  })
})
```

### 8.2 E2Eテスト

```typescript
// tests/e2e/transaction.spec.ts
import { test, expect } from "@playwright/test"

test.describe("Transaction Management", () => {
  test.beforeEach(async ({ page }) => {
    // ログイン処理
    await page.goto("/login")
    await page.click('button:has-text("Googleでログイン")')
    // OAuth mockまたはテスト用認証
    await page.waitForURL("/dashboard")
  })

  test("should create a new expense", async ({ page }) => {
    await page.goto("/dashboard/expense/new")
    
    // フォーム入力
    await page.fill('input[name="amount"]', "1000")
    await page.selectOption('select[name="categoryId"]', "食費")
    await page.fill('input[name="vendor"]', "スーパーマーケット")
    await page.fill('textarea[name="description"]', "夕食の買い物")
    
    // 送信
    await page.click('button:has-text("登録")')
    
    // 成功メッセージ確認
    await expect(page.locator('text="支出を登録しました"')).toBeVisible()
    
    // リダイレクト確認
    await expect(page).toHaveURL("/dashboard/expense")
  })

  test("should display transaction list", async ({ page }) => {
    await page.goto("/dashboard/expense")
    
    // テーブルの存在確認
    await expect(page.locator("table")).toBeVisible()
    
    // データの存在確認
    await expect(page.locator("tbody tr")).toHaveCount(
      await page.locator("tbody tr").count()
    )
  })
})
```

## 9. デプロイメント設定

### 9.1 Vercel設定

```json
// vercel.json
{
  "functions": {
    "src/app/api/cron/recurring-transactions/route.ts": {
      "maxDuration": 10
    }
  },
  "crons": [
    {
      "path": "/api/cron/recurring-transactions",
      "schedule": "0 0 * * *"
    },
    {
      "path": "/api/cron/backup",
      "schedule": "0 2 * * *"
    }
  ]
}
```

### 9.2 環境変数

```env
# .env.production
# Database
DATABASE_URL="postgresql://..."
DIRECT_URL="postgresql://..."

# NextAuth
NEXTAUTH_URL="https://family-finance.vercel.app"
NEXTAUTH_SECRET="..."

# OAuth - Google
GOOGLE_CLIENT_ID="..."
GOOGLE_CLIENT_SECRET="..."

# OAuth - Microsoft
AZURE_AD_CLIENT_ID="..."
AZURE_AD_CLIENT_SECRET="..."
AZURE_AD_TENANT_ID="..."

# Whitelist
USER1_EMAIL="user1@example.com"
USER2_EMAIL="user2@example.com"

# Cron
CRON_SECRET="..."

# Supabase
SUPABASE_URL="..."
SUPABASE_ANON_KEY="..."
SUPABASE_SERVICE_KEY="..."
```

## 10. 運用・保守

### 10.1 監視項目

```typescript
// src/lib/monitoring/metrics.ts
export class Metrics {
  static async recordApiCall(
    endpoint: string, 
    method: string, 
    responseTime: number,
    statusCode: number
  ) {
    // Vercel Analytics or custom monitoring
    console.log({
      type: "api_call",
      endpoint,
      method,
      responseTime,
      statusCode,
      timestamp: new Date().toISOString()
    })
  }

  static async recordError(
    error: Error,
    context: Record<string, any>
  ) {
    // Sentry or custom error tracking
    console.error({
      type: "error",
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    })
  }
}
```

### 10.2 バックアップスクリプト

```typescript
// scripts/backup.ts
import { prisma } from "@/lib/db/prisma"
import { createWriteStream } from "fs"
import { pipeline } from "stream/promises"
import { format } from "date-fns"

async function backup() {
  const timestamp = format(new Date(), "yyyyMMdd_HHmmss")
  const fileName = `backup_${timestamp}.json`
  
  const data = {
    users: await prisma.user.findMany(),
    categories: await prisma.category.findMany(),
    transactions: await prisma.transaction.findMany(),
    paymentMethods: await prisma.paymentMethod.findMany(),
    budgets: await prisma.budget.findMany(),
    goals: await prisma.goal.findMany()
  }
  
  const writeStream = createWriteStream(fileName)
  await pipeline(
    JSON.stringify(data, null, 2),
    writeStream
  )
  
  console.log(`Backup completed: ${fileName}`)
}

backup().catch(console.error)
```

---
作成日：2024年11月
作成者：システム設計チーム
バージョン：1.0